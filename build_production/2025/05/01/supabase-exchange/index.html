<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://queen.raae.codes/2025/05/01/supabase-exchange">
        <meta name="description" content="Ahoy, seasoned JavaScript developers and daring dev pirates! Join our swashbuckling crew as we embark on thrilling treasure hunts unraveling the secrets of HTML, CSS, and JavaScript, all while having a blast!">
        <title>How to use JWT from any auth provider with Supabase RLS</title>
                <link rel="stylesheet" href="/assets/build/assets/main-BZO06M8j.css">
        <script defer type="module" src="/assets/build/assets/main-l0sNRNKZ.js"></script>
    </head>
    <body class="text-gray-900 font-sans antialiased">
        <article class="max-w-3xl mx-auto px-4 py-8">
    <header class="mb-8">
        <h1 class="text-4xl font-bold text-brown-900 mb-4">How to use JWT from any auth provider with Supabase RLS</h1>

        
                    <div class="mt-4 flex flex-wrap gap-2">
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        JWT
                    </span>
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        RLS
                    </span>
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        Auth
                    </span>
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        Authorization
                    </span>
                            </div>
            </header>

    <div class="prose prose-lg prose-brown max-w-none">
        <p>Supabase provides Row Level Security (RLS) as a way to control access to your data. RLS makes it possible to query data from your client without an API layer. But what if you want to use your existing authentication system, instead of Supabase Auth?</p>

<p>This is something our <a href="https://outseta.com/?via=queen&amp;utm_source=queen&amp;utm_medium=blog&amp;utm_campaign=supabase-exchange">Outseta</a> users struggled with. I was pretty sure it was possible, but it took me some time to come up with the solution. I realised it could be used with any JWT-based auth provider, so I thought I'd share the solution here as well.</p>

<aside class="notice">

I've also created a full [React + Supabase + Outseta demo app](https://outseta-supabase-react-feedback-fort.netlify.app/) that you can use as a starting point for your own project. Full source code is available on [GitHub](https://github.com/outseta/outseta-supabase-react-feedback-fort).

</aside>

<h2>The Problem</h2>

<p>You have an existing authentication system that issues JWTs, but you want to leverage Supabase's Row Level Security (RLS) features that expect Supabase-signed tokens.</p>

<h2>The Solution</h2>

<p>Exchange your authentication provider's JWT for a Supabase-signed JWT, then use the latter for all Supabase operations.</p>

<h2>How It Works</h2>

<p>The token exchange must happen server-side and follows these steps:</p>

<ol>
<li><strong>Verify the original JWT</strong> using your auth provider's public key or JWKS endpoint</li>
<li><strong>Create a new JWT</strong> with additional claims required by Supabase</li>
<li><strong>Sign the new JWT</strong> with your Supabase JWT Secret</li>
<li><strong>Use the Supabase-signed JWT</strong> in subsequent requests</li>
</ol>

<h2>Implementation Steps</h2>

<h3>1. Set Up Your Authentication Provider</h3>

<p>And take note of the shape for the JWT payload they provide, typical it will include things like:</p>

<ul>
<li><code>sub</code>: The unique ID of the authenticated user</li>
<li><code>email</code>: User's email address</li>
<li><code>name</code>: User's name</li>
<li><code>org_id</code>: User's organisation ID</li>
</ul>

<p>For an example, check out the <a href="https://go.outseta.com/support/kb/articles/XQYMXqQP/the-jwt-access-token?utm_source=queen&amp;utm_medium=blog&amp;utm_campaign=supabase-exchange">Outseta JWT docs</a>.</p>

<h3>2. Create an Exchange Function</h3>

<p>Deploy a server-side function that handles the token exchange. This can be:</p>

<ul>
<li>A Supabase Edge Function</li>
<li>An API route in your application server</li>
<li>A serverless function somewhere</li>
</ul>

<p>We'll use a Supabase Edge Function for this example, but the same principles apply to any server-side function.</p>

<p>You'll need the following environment variables for the Edge Function (found in Supabase Console under Edge Functions -> Secrets):</p>

<ul>
<li><code>SUPABASE_JWT_SECRET</code>: Your Supabase JWT secret (found in the Supabase Console under Project Settings -> Data API)</li>
<li><code>AUTH_JWKS_URL</code>: The JWKS URL for your auth provider (found in the auth provider's docs)

<ul>
<li>or <code>AUTH_PUBLIC_KEY</code>: The public key for your auth provider (found in the auth provider's docs)</li>
</ul></li>
</ul>

<p>To deploy the function, run:</p>

<pre><code class="language-bash">supabase functions deploy exchange --no-verify-jwt
</code></pre>

<p>or upload the function from the Supabase Console making sure to disable the "Enforce JWT Verification" option.</p>

<p>The <code>--no-verify-jwt</code> flag is essential because this endpoint is requested with the JWTs from your external auth provider, not a Supabase-signed tokens. Without this flag, Supabase would automatically reject these requests as it would try to verify them as Supabase JWTs.</p>

<p>Here's a sample exchange function using Supabase Edge Functions:</p>

<pre><code class="language-typescript">// File: /functions/exchange/index.ts
// Deploy with: supabase functions deploy exchange --no-verify-jwt

import * as jose from "https://deno.land/x/jose@v4.14.4/index.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

Deno.serve(async (req) =&gt; {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  // Get the original JWT from the Authorization header
  const authHeader = req.headers.get("Authorization");
  const originalJwt = authHeader?.split(" ")[1] || "";

  try {
    // OPTION 1: Verify with JWKS URL
    const JWKS = jose.createRemoteJWKSet(new URL(Deno.env.get("AUTH_JWKS_URL")));

    // OPTION 2: Verify with public key
    // const publicKey = await jose.importSPKI(Deno.env.get("AUTH_PUBLIC_KEY"), "RS256");

    // Verify the token
    const { payload } = await jose.jwtVerify(originalJwt, JWKS);

    // Add the required role claim if not already present for a valid Supabase JWT
    payload.role = "authenticated"; // Required by Supabase

    // Add or modify any other claims you need for RLS policies
    // payload.some_claim = "some claim";

    // Sign with Supabase JWT secret
    const supabaseSecret = new TextEncoder().encode(Deno.env.get("SUPABASE_JWT_SECRET"));

    const supabaseJwt = await new jose.SignJWT(payload)
      .setProtectedHeader({ alg: "HS256", typ: "JWT" })
      .setIssuer("supabase")
      .setIssuedAt(payload.iat)
      .setExpirationTime(payload.exp || "")
      .sign(supabaseSecret);

    // Return the Supabase JWT
    return new Response(JSON.stringify({ supabaseJwt }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 200,
    });
  } catch (error) {
    console.error("JWT verification failed:", error.message);
    return new Response(JSON.stringify({ error: "Invalid token" }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 401,
    });
  }
});
</code></pre>

<h3>3. Use the Exchanged JWT with Supabase Client</h3>

<p>The most elegant way to use the exchanged JWT is to configure the Supabase client with a custom accessToken handler that automatically exchanges tokens:</p>

<pre><code class="language-javascript">import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Create Supabase client with automatic token exchange
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  accessToken: async (fallbackToken) =&gt; {
    // Get the original JWT from your auth provider
    const originalJwt = getAuthProviderToken(); // Replace with your auth provider's method

    if (!originalJwt) {
      return null; // No token available
    }

    // Exchange it for a Supabase token
    const supabaseJwt = await exchangeToken(originalJwt);
    return supabaseJwt || fallbackToken;
  },
});

// Function to exchange the original JWT for a Supabase JWT
async function exchangeToken(originalJwt) {
  // Perhaps add some caching here to avoid unnecessary exchanges,
  // only need to exchange if originalJwt has changed
  try {
    console.log("Exchanging token for Supabase access");
    const response = await fetch(`${supabaseUrl}/functions/v1/exchange`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${originalJwt}`,
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      throw new Error(`Token exchange failed: ${response.status}`);
    }

    const { supabaseJwt } = await response.json();
    return supabaseJwt;
  } catch (error) {
    console.error("Error exchanging token:", error);
    return null;
  }
}

// Example usage - just use the supabase client normally!
// The token exchange happens automatically behind the scenes
const { data, error } = await supabase.from("my_table").select("*");
</code></pre>

<h2>Creating RLS Policies with the Exchanged JWT</h2>

<p>Supabase makes the decoded JWT available in RLS policies through the built-in <code>auth.jwt()</code> function:</p>

<pre><code class="language-sql">-- Example: Only allow users to read their own records
CREATE POLICY "Users can read their own data" ON my_table
  FOR SELECT
  -- Using auth.jwt() -&gt;&gt; 'sub'instead of auth.uid() as you could with Supabase auth
  USING (auth.jwt() -&gt;&gt; 'sub' = user_id);

-- Example: Organization-based access if you have an org_id claim
CREATE POLICY "Users can access organization data" ON org_resources
  FOR ALL
  USING (auth.jwt() -&gt;&gt; 'org_id' = organization_id);
</code></pre>

<h2>Setting Default Values from JWT Claims</h2>

<p>You can also use JWT claims as default values for table columns:</p>

<pre><code class="language-sql">-- Example: Automatically set the user_id when a record is created
ALTER TABLE my_table
  ALTER COLUMN user_id SET DEFAULT auth.jwt() -&gt;&gt; 'sub';

-- Example: Set organization_id from JWT claim
ALTER TABLE org_resources
  ALTER COLUMN organization_id SET DEFAULT auth.jwt() -&gt;&gt; 'org_id';
</code></pre>

<h2>Important Considerations</h2>

<ol>
<li><strong>Security</strong>: Always verify the original JWT on the server side before exchanging it</li>
<li><strong>Claims Mapping</strong>: Transfer all relevant claims from the original JWT to the Supabase JWT</li>
<li><strong>Expiration</strong>: Preserve the original token's expiration time in the Supabase token</li>
<li><strong>Error Handling</strong>: Handle verification failures gracefully</li>
</ol>

<h2>Conclusion</h2>

<p>By implementing this token exchange pattern, you can continue using your existing authentication system while taking full advantage of Supabase's powerful RLS capabilities. This approach gives you the flexibility to use any JWT-based auth provider that does not have a built-in Supabase integration, such as <a href="https://outseta.com/?via=queen&amp;utm_source=queen&amp;utm_medium=blog&amp;utm_campaign=supabase-exchange">Outseta</a>.</p>

<p>Happy building! ðŸš€</p>
    </div>
</article>
    </body>
</html>
