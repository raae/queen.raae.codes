<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://queen.raae.codes/2023/01/13/xata-workers-part-1">
        <meta name="description" content="Ahoy, seasoned JavaScript developers and daring dev pirates! Join our swashbuckling crew as we embark on thrilling treasure hunts unraveling the secrets of HTML, CSS, and JavaScript, all while having a blast!">
        <title>Exploring Xata (Cloudflare) Workers for Prune your Follows</title>
                <link rel="stylesheet" href="/assets/build/assets/main-BZO06M8j.css">
        <script defer type="module" src="/assets/build/assets/main-l0sNRNKZ.js"></script>
    </head>
    <body class="text-gray-900 font-sans antialiased">
        <article class="max-w-3xl mx-auto px-4 py-8">
    <header class="mb-8">
        <h1 class="text-4xl font-bold text-brown-900 mb-4">Exploring Xata (Cloudflare) Workers for Prune your Follows</h1>

        
                    <div class="mt-4 flex flex-wrap gap-2">
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        serverless
                    </span>
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        search
                    </span>
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        treasure hunt
                    </span>
                            </div>
            </header>

    <div class="prose prose-lg prose-brown max-w-none">
        <p>As soon as Prune your Follows facilitates 500 unfollows in 24 hours, it gets blocked by Twitter for 24 hours.</p>

<p>To combat this, we think that some type of queuing architecture is needed. Feel free to reply if you have any input!</p>

<p>So we decided to explore Xata Workers on this week's <a href="https://youtu.be/O89C_yxZK3o">unauthorized and rum-fueled treasure hunt</a> as Xata Workers is built on top of <a href="https://developers.cloudflare.com/workers">Cloudflare Workers</a> and Cloudflare also has <a href="https://developers.cloudflare.com/queues/">Cloudflare Queues</a> ü§î</p>

<p><a href="https://youtu.be/O89C_yxZK3o"><img src="./screengrab.jpg" alt="Screengrab of stream with crazy looking Captain Ola and funny looking Pirate Princess" /></a></p>

<p>To my surprise <a href="https://youtu.be/O89C_yxZK3o?t=1558">we did get a Worker working</a> locally while on stream ü•≥</p>

<p>However, we did not handle authenticating the user inside our Xata Worker. Needed to make sure the user has access and only gets relevant records.</p>

<p>Pirate Shai to the rescue; hopefully, time will tell...</p>

<p><a href="https://twitter.com/shaisc/status/1613679030494023682"><img src="./twitter.com_shaisc.png" alt="getToken() is a shortcut wrapper that uses process.env, which doesn't exist in the Xata Worker, but you can instead use decode() directly and pass it the token (from request.headers) and secret (from env) yourself" /></a></p>

<h2>The How</h2>

<ol>
<li>We initialized Xata Workers in our exiting Xata project <code>xata workers init</code>,</li>
<li>defined a Xata Worker, copy/past-ing the code from our Gatsby Function,</li>
<li>and then used the defined Worker directly in our <code>useQuery</code> replacing the GET request to <code>/api/account</code></li>
</ol>

<p>The Xata CLI will magically cut out the Xata Worker code and deploy it to Cloudflare for us, using <code>xata upload</code> ü§Ø</p>

<p>For local development, we used <code>xata workers watch</code>. Not completly sure what happens then üò¨</p>

<pre><code class="language-jsx">import { useQuery } from "@tanstack/react-query";
import { useUser } from "../user";

import { xataWorker } from "./../../xata";

// Define Xata Worker 1Ô∏è‚É£
const searchAccount = xataWorker(
  "searchAccount",
  async ({ xata }, { search }) =&gt; {
    const searchResults = await xata.search.all(search, {
      tables: [
        {
          table: "accounts",
          target: [
            { column: "name", weight: 3 },
            { column: "username", weight: 7 },
            { column: "meta.location" },
            { column: "meta.description" },
          ],
        },
      ],
      highlight: { enabled: true },
      fuzziness: 1,
      prefix: "phrase",
    });

    const records = searchResults.map((result) =&gt; {
      return {
        ...result,
        searchInfo: result.record.getMetadata(),
      };
    });

    return { records };
  }
);

export default function useSearch({ search }) {
  const { data: user } = useUser();

  return useQuery(
    ["accounts", user?.id, "search", search],
    async () =&gt; {
      // Use the Xata Worker 2Ô∏è‚É£
      return searchAccount({ search: search });
    },
    {
      enabled: Boolean(user?.enableQueries) &amp;&amp; Boolean(search),
      keepPreviousData: true,
    }
  );
}
</code></pre>

<p>As mentioned, this code is incomplete, as we need to filter the accounts by the authenticated user.</p>

<p>Sign up for an <a href="/emails/reminders/">email reminder</a> to ensure you catch the next stream, where we'll try to make that happen.</p>

<p>&nbsp;</p>

<p>All the best,\
Queen Raae</p>

<p>PS: Follow the <a href="https://github.com/queen-raae/prune-your-follows/pull/74">Pull Request</a> if you are very interested ü§™</p>
    </div>
</article>
    </body>
</html>
