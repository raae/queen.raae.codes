<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://queen.raae.codes/2022/03/24/parrot-pages">
        <meta name="description" content="Ahoy, seasoned JavaScript developers and daring dev pirates! Join our swashbuckling crew as we embark on thrilling treasure hunts unraveling the secrets of HTML, CSS, and JavaScript, all while having a blast!">
        <title>Multiple parrot pages for the same node type in Gatsby</title>
                <link rel="stylesheet" href="/assets/build/assets/main-BZO06M8j.css">
        <script defer type="module" src="/assets/build/assets/main-l0sNRNKZ.js"></script>
    </head>
    <body class="text-gray-900 font-sans antialiased">
        <article class="max-w-3xl mx-auto px-4 py-8">
    <header class="mb-8">
        <h1 class="text-4xl font-bold text-brown-900 mb-4">Multiple parrot pages for the same node type in Gatsby</h1>

        
                    <div class="mt-4 flex flex-wrap gap-2">
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        file system route api
                    </span>
                                    <span class="px-3 py-1 bg-brown-100 text-brown-800 rounded-full text-sm">
                        gatsby-source-filesystem
                    </span>
                            </div>
            </header>

    <div class="prose prose-lg prose-brown max-w-none">
        <p>How can you achieve different page layouts for content with the same content node type but varying content types such as posts, projects, and pages?</p>

<p>The approach covered in yesterday's email used <a href="/2022-03-23-page-components/">multiple page components</a>; the day before was <a href="/2022-03-22-page-templates/">multiple page templates</a> and today we are covering my current favorite: <em>multiple parrot pages</em>.</p>

<p>If you are not familiar with the term parrot pages, it's what we call files system routes around the Gatsby islands ðŸ¤ª</p>

<h2>Multiple Parrot Pages ðŸ¦œ</h2>

<p>The title is a little misleading as we cannot make multiple parrot pages for the same node type. But we'll use a nice little trick of creating new nodes named after the content type, resulting in the opportunity to make multiple parrot pages:</p>

<pre><code>src/
â”œâ”€ pages/
â”‚  â”œâ”€ post/
â”‚  â”‚  â”œâ”€ {Post.slug}.js
â”‚  â”œâ”€ project/
â”‚  â”‚  â”œâ”€ {Project.slug}.js
</code></pre>

<p>We create new nodes by hooking into the <code>onCreateNode</code> extension point:</p>

<pre><code class="language-js">// gatsby-node.js
const { createFilePath } = require("gatsby-source-filesystem");

exports.onCreateNode = (gatsbyUtils) =&gt; {
  const { actions, node, getNode, reporter, createNodeId } = gatsbyUtils;
  const { createNode } = actions;

  if (node.internal.type === "MarkdownRemark") {
    const parentFileNode = getNode(node.parent);
    const contentType = parentFileNode?.sourceInstanceName || "";

    const contentNodeId = createNodeId(`${node.id} &gt;&gt;&gt; ${contentType}`);
    const slug = createFilePath({ node: parentFileNode, getNode });

    createNode({
      id: contentNodeId,
      slug: slug,
      childMarkdownRemark: node.id, // ðŸ‘ˆ
      internal: {
        contentDigest: node.internal.contentDigest,
        type: contentType,
      },
    });

    reporter.info(`${contentType} created for ${slug}`);
  }
};
</code></pre>

<p>Take note of the childMarkdownRemark key added to the new node! It's what connects the new node to its content. However, if we query the new nodes at this point, we'll only get the node id.</p>

<p>How can we get the full content? By modifying their schema using <code>@link</code>:</p>

<pre><code class="language-js">// gatsby-node.js

exports.createSchemaCustomization = ({ actions }) =&gt; {
  const { createTypes } = actions;

  const typeDefs = `
    type Post implements Node {
      slug: String
      childMarkdownRemark: MarkdownRemark @link
    }
    type Project implements Node {
      slug: String
      childMarkdownRemark: MarkdownRemark @link
    }
  `;

  createTypes(typeDefs);
};
</code></pre>

<p>Now inside our parrot pages, we can query for the content on childMarkdownRemark:</p>

<pre><code class="language-js">// {Post.slug}.js

import React from "react";
import { graphql } from "gatsby";

const PostPage = ({ data }) =&gt; {
  const { html, frontmatter } = data.post?.childMarkdownRemark;
  const { title } = frontmatter;
  return (
    &lt;main&gt;
      &lt;article&gt;
        &lt;header&gt;
          &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;/header&gt;
        &lt;section dangerouslySetInnerHTML={{ __html: html }} /&gt;
      &lt;/article&gt;
    &lt;/main&gt;
  );
};

export default PostPage;

export const query = graphql`
  query ($id: String!) {
    post(id: { eq: $id }) {
      childMarkdownRemark {
        html
        frontmatter {
          title
        }
      }
    }
  }
`;
</code></pre>

<p>Same as the other days, the <code>sourceInstanceName</code> used comes from configuring your <code>gatsby-source-filesystem</code> with the <code>name</code> option.</p>

<pre><code class="language-js">// gatsby-config.js
module.exports = {
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/content/posts`,
        name: "Post",
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        path: `${__dirname}/content/projects`,
        name: "Project",
      },
    },
  ],
};
</code></pre>

<p>How do you solve different page layouts for content with the same content node type but varying content types?</p>

<p>&nbsp;<br />
All the best,<br />
Queen Raae</p>
    </div>
</article>
    </body>
</html>
