---
import { getCollection } from 'astro:content';
import BaseLayout from '../layouts/BaseLayout.astro';
import SiteHeader from '../components/SiteHeader.astro';
import PageSection from '../components/PageSection.astro';
import PageSectionHeader from '../components/PageSectionHeader.astro';
import PageSectionBreadcrumbs from '../components/PageSectionBreadcrumbs.astro';
import Newsletter from '../components/Newsletter.astro';
import Badge from '../components/Badge.astro';
import ContentList from '../components/ContentList.astro';

export async function getStaticPaths() {
  const queenPosts = await getCollection('posts-queen');
  const olaPosts = await getCollection('posts-olavea');
  const allPosts = [...queenPosts, ...olaPosts];

  return allPosts.map((post) => ({
    params: { slug: post.slug },
    props: { post, allPosts },
  }));
}

const { post, allPosts } = Astro.props;
const { Content } = await post.render();

// Extract date from slug (format: YYYY/MM/DD-title)
const dateMatch = post.id.match(/(\d{4})\/(\d{2})\/(\d{2})/);
const dateStr = dateMatch ? `${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}` : '';
const dateObj = dateMatch ? new Date(`${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`) : null;

// Format date like "January 25th, 2025"
function formatDate(date: Date): string {
  const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'long', day: 'numeric' };
  const formatted = date.toLocaleDateString('en-US', options);
  const day = date.getDate();
  const suffix = day === 1 || day === 21 || day === 31 ? 'st'
               : day === 2 || day === 22 ? 'nd'
               : day === 3 || day === 23 ? 'rd'
               : 'th';
  return formatted.replace(/(\d+),/, `$1${suffix},`);
}

const formattedDate = dateObj ? formatDate(dateObj) : '';

// Parse tags
const tags = post.data.tags ? post.data.tags.split(',').map((t: string) => {
  const trimmed = t.trim();
  return {
    label: trimmed.toLowerCase(),
    slug: `/tag/${trimmed.toLowerCase().replace(/\s+/g, '-')}/`
  };
}) : [];

// Find related posts based on tags
const currentTags = post.data.tags ? post.data.tags.split(',').map((t: string) => t.trim().toLowerCase()) : [];
const relatedPosts = allPosts
  .filter(p => p.slug !== post.slug && p.data.tags)
  .map(p => {
    const pTags = (p.data.tags || '').split(',').map((t: string) => t.trim().toLowerCase());
    const commonTags = currentTags.filter((tag: string) => pTags.includes(tag));
    return { post: p, score: commonTags.length };
  })
  .filter(p => p.score > 0)
  .sort((a, b) => b.score - a.score)
  .slice(0, 3)
  .map(p => {
    const dateMatch = p.post.id.match(/(\d{4})\/(\d{2})\/(\d{2})/);
    const dateStr = dateMatch ? `${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}` : '';
    const dateObj = dateMatch ? new Date(`${dateMatch[1]}-${dateMatch[2]}-${dateMatch[3]}`) : null;
    return {
      ...p.post,
      dateStr,
      formattedDate: dateObj ? formatDate(dateObj) : '',
    };
  });
---

<BaseLayout title={post.data.title} description={post.data.description}>
  <main>
    <PageSection component="article">
      <PageSectionBreadcrumbs
        class="mt-4"
        items={[
          { label: 'Posts', to: '/posts/' },
          { label: formattedDate }
        ]}
      />

      <PageSectionHeader hLevel={1} title={post.data.title} />

      {tags.length > 0 && (
        <aside class="space-x-2">
          {tags.map((tag: {label: string, slug: string}) => (
            <Badge href={tag.slug}>{tag.label}</Badge>
          ))}
        </aside>
      )}

      <div class="prose prose-brown prose-lg max-w-none mt-12">
        <Content />
      </div>
    </PageSection>

    <PageSection component="footer">
      <Newsletter
        tagline="Interested in more daily treasures like this one?"
        message="Sent directly to your inbox?"
      />
    </PageSection>

    {relatedPosts.length > 0 && (
      <PageSection>
        <PageSectionHeader hLevel={2} lead="You might also be interested in..." />
        <ContentList items={relatedPosts.map(p => ({
          to: `/${p.slug}/`,
          primary: p.data.title,
          secondary: p.formattedDate
        }))} />
      </PageSection>
    )}
  </main>
</BaseLayout>
